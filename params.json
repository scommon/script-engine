{"name":"Scala Script Engine","tagline":"Fork of ScalaScriptEngine (https://code.google.com/p/scalascriptengine/).","body":"### Description\r\nThis library dynamically compiles scala source files and loads them as classes. Changed scala files will be recompiled and the changed class with be loaded. Multiple source paths are supported as well as compilation class path and class loading class paths (so that the scripts can load extra libraries).\r\n\r\nClasspath detection can be automatic (effectively using the classpath of the caller) or manual.\r\n\r\nDifferent compilation and refreshing strategies are provided to suit various purposes.\r\n\r\n### News\r\n- 23/07/2013 : v1.3.5 is available with error reporting fixes and only for scala 2.10.2\r\n- 30/06/2013 : v1.3.4 is available, with error reporting fixes and only for scala 2.10.2\r\n- 24/04/2013 : v1.3.2 is available with class loading listeners\r\n- 02/03/2013 : v1.3.1 is available with better error reporting\r\n- 20/02/2013 : v1.3.0 is available with better support for using ScalaScriptEngine within an IDE and multiple target class folders.\r\n- 09/02/2013 : v1.2.1 is now available with better compilation error reporting and sbt compatibility fix.\r\n- 23/01/2013 : snapshots of v1.2.1 are available in sonatype snapshot repo. Those fix sbt issues.\r\n- 12/01/2013 : v1.2.0 for scala 2.10.0 is now available\r\n- 16/10/2012 : v1.2.0 : Sandbox, better eval() and compilation for scala 2.9.2 and 2.10.0-M7 . For Sandbox please look at the end of this page.\r\n- 25/08/2012 : v1.1.0 : this has support for evaluating scala code from a String.\r\n- 22/07/2012 : migrated to git\r\n- 19/07/2012 : v1.0.0 : v0.6.4 is promoted to v1.0.0\r\n\r\n[more...](wiki/News)\r\n\r\n### Examples\r\n[Please click to view examples](src/test/scala/examples)\r\n\r\n[eval(): Evaluating scala code from a String](src/test/scala/com/googlecode/scalascriptengine/EvalCodeSuite.scala)\r\n\r\n### Discuss\r\nat http://groups.google.com/group/scala-script-engine\r\n\r\n### Maven\r\nBoth scalascriptengine and scala-compiler must be added as dependencies:\r\n\r\n```xml\r\n<dependency>\r\n        <groupId>com.googlecode.scalascriptengine</groupId>\r\n        <artifactId>scalascriptengine</artifactId>\r\n        <version>1.3.2-${scala.version}</version>\r\n</dependency>\r\n<dependency>\r\n        <groupId>org.scala-lang</groupId>\r\n        <artifactId>scala-compiler</artifactId>\r\n        <version>${scala.version}</version>\r\n</dependency>\r\n```\r\n\r\nPlease add the sonatype releases repository to your repositories:\r\n\r\n```xml\r\n<repositories>\r\n        <repository>\r\n                <id>sonatype.releases</id>\r\n                <url>https://oss.sonatype.org/content/repositories/releases/</url>\r\n        </repository>\r\n</repositories>\r\n```\r\n\r\n### sbt\r\n\r\n```\r\n\"com.googlecode.scalascriptengine\" % \"scalascriptengine\" % \"1.3.2-${scala.version}\",\r\n\"org.scala-lang\" % \"scala-compiler\" % \"${scala.version}\" // where i.e. ${scala.version} = 2.9.2\r\n```\r\n\r\n### Usage\r\nThis is not the most efficient usage of the library, but is the one with the most expected behavior:\r\n\r\n```scala\r\n// sourceDir is the folder with the scala source files\r\nval sse = ScalaScriptEngine.onChangeRefresh(sourceDir)\r\n// get the class which should extend statically\r\n// compiled trait ClzTrait\r\nval clzTraitClass=sse.get[ClzTrait](\"my.dynamic.Clz\")\r\n// or get a new instance\r\nval clzTrait=sse.newInstance[ClzTrait](\"my.dynamic.Clz\")\r\n```\r\n\r\nPlease note that scala classes that are going to be requested from ScalaScriptEngine, should be declared in a synonymous scala file, i.e. my.Foo should be under my/Foo.scala in order for change detection to work.\r\n\r\n### Avoiding compilation during development\r\nThe engine can be configured to use classes as they are compiled by an IDE.\r\n\r\n```scala\r\nval sse=if(is running for production)\r\n  ...normal script engine initialization for production env\r\nelse\r\n  new ScalaScriptEngine(Config(sourcePaths = List(\r\n    SourcePath(...source folder, i.e. src/main/scala..., ... existing class folder, i.e. target/classes)\r\n  ))) with DevUseIDECompiledClassesOnly\r\n```\r\n\r\nNow scripts can be recompiled within the IDE and, without restarting your java app, the compiled classes will be reloaded on every sse.get or sse.newInstance.\r\n\r\nNOTE: this frequently throws away a classloader and it is not recommended for production as it is slow and will cause a PermGen issue. But it is very handy during development.\r\n\r\n### Examples\r\n- [Please click to view examples](src/test/scala/examples)\r\n\r\n### How does it work\r\nThe ScalaScriptEngine class works by keeping versions of compiled source directories. Version 1 can be loaded during initialization of the engine or during the request for the first script. After that, there are different policies to refresh the changed source files:\r\n\r\n- **manual**: the client of the engine manually calls ScalaScriptEngine.refresh to check & recompile changed classes in the source directories.\r\n- **on-change-refresh**: as soon as the src file for a requested class changes, the source dirs are recompiled (only changed files). The code requesting for the changed class blocks till compilation completes\r\n- **on-change-refresh-async**: as soon as the src file for a requested class changes, the source dirs are recompiled (only changed files). The code requesting for the changed class resumes execution but uses an old version of the class till compilation completes. This method scales up better for i.e. servers that need to process hundreds of requests per second and blocking till compilation completes is not an option.\r\n- **timed refresh**: a background thread periodically scans the source folders for changes and recompiles them. During recompilation, old version classes are returned by the engine but as soon as compilation completes the new version classes are used.\r\n\r\nIn case of compilation errors, the previous version remains in use.\r\n\r\n### Sandbox\r\nPlease view the test suites:\r\n\r\n- [policy file](testfiles/SandboxSuite/test.policy) \r\n- [Example 1](src/test/scala/com/googlecode/scalascriptengine/SandboxSuite.scala)\r\n- [Example 2](src/test/scala/com/googlecode/scalascriptengine/SandboxAllowOnlySuite.scala)\r\n\r\nScalaScriptEngine can be configured to work with a Java sandbox and in addition offers extra help in terms of SecureManager and limited classloading for scripts.\r\n\r\n### Sandbox and SecureManager\r\ncreate a policy file:\r\n\r\n```\r\ngrant codeBase \"file:${user.home}/-\" {\r\n        permission java.security.AllPermission;\r\n};\r\n\r\ngrant codeBase \"${script.classes}/-\" {\r\n        permission java.io.FilePermission       \"/home\",\"read\";\r\n};\r\n```\r\n\r\nRegister a SecurityManager with the help of SSESecurityManager:\r\n\r\n```scala\r\nimport com.googlecode.scalascriptengine._\r\n\r\n// create the default config with a Source Dir. The temp directory where\r\n// the compiled classes are stored is in the OS tmp folder.\r\nval config = ScalaScriptEngine.defaultConfig(sourceDir)\r\n// We are now going to create a security manager with the test.policy\r\n// file. We need to fill the placeholders of test.policy\r\nSystem.setProperty(\"script.classes\", config.outputDir.toURI.toString)\r\nSystem.setProperty(\"java.security.policy\", new File(\"test.policy\").toURI.toString)\r\nval sseSM = new SSESecurityManager(new SecurityManager)\r\nSystem.setSecurityManager(sseSM)\r\n```\r\n\r\nThe SSESecurityManager is by default not active. So the rest of the java code will run like if not under a security manager. The SSESecurityManager activates the delegate SecurityManager as follows:\r\n\r\n```scala\r\nval sse = ScalaScriptEngine.onChangeRefresh(config, 5)\r\nsse.deleteAllClassesInOutputDirectory\r\nsse.refresh\r\n\r\nsseSM.secured {\r\n        // now the delegated SecurityManager is active and hence test.policy is active\r\n        val tct = sse.newInstance[TestClassTrait](\"test.TryFile\")\r\n        tct.result should be === \"directory\"\r\n}\r\n```\r\n\r\nPlease note: SSESecurityManager can be bypassed and a global SecurityManager can be installed for both the main scala app and the scripts. SSESecurityManager is provided as a helper to avoid running all code under a security manager.\r\n\r\n### Configuring limited access to loaded classes\r\nScripts can be limited to i.e. not be able to load classes from specific packages. The decision is just a function (packageName,fullClassName)=>Boolean. If true, access to fullClassName class is allowed otherwise AccessControlException is thrown.\r\n\r\nThe following example allows access only to certain packages and i.e. Threads can't be created by the scripts (except ofcourse if one of the allowed packages contains a class that creates threads):\r\n\r\n```scala\r\nval allowedPackages = Set(\r\n        \"java.lang\",\r\n        \"scala\",\r\n        \"com.googlecode.scalascriptengine\")\r\nval config = ScalaScriptEngine.defaultConfig(sourceDir).copy(\r\n        classLoaderConfig = ClassLoaderConfig.default.copy(\r\n                allowed = { (pckg, name) =>\r\n                        allowedPackages(pckg) || pckg == \"test\"\r\n                }\r\n        )\r\n)\r\nval sse = ScalaScriptEngine.onChangeRefresh(config, 5)\r\nsse.deleteAllClassesInOutputDirectory\r\nsse.refresh\r\n\r\nval t = sse.newInstance[TestClassTrait](\"test.TryPackage\")\r\n// if test.TryPackage tries to use a class not in the allowed\r\n// packages, an AccessControlException will be thrown \r\nt.result\r\n```\r\n\r\n\r\nPlease note this mechanism works independently of a security manager. No security manager is required as this mechanism works during classloading.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}